---
title: "Bayesian Rasch & reliability"
subtitle: "Comparing methods"
author:
  name: 'Magnus Johansson'
  affiliation: 'Karolinska Institutet'
  orcid: '0000-0003-1669-592X'
date: 2025-10-11
date-format: iso
google-scholar: true
citation:
  type: 'webpage'
format: 
  html:
    code-fold: true
execute: 
  cache: true
  warning: false
  message: false
editor_options: 
  chunk_output_type: console
#bibliography: est_comp.bib
---

## Introduction

This post has two purposes. The primary one is to compare some reliability metrics, since a new paper [@] inspired some ideas. The main idea I had was to use plausible values instead of fully Bayesian model posterior draws to estimate the "relative measurement uncertainty" (RMU) metric proposed by Bignardi and colleagues. The secondary purpose is to show how to fit Rasch models, dichotomous and partial credit models, using Bayesian models with `brms`, and make some comparisons of person and item parameters relative CML/WLE estimation. There is already an excellent paper on Bayesian Item Response Modeling [@], but I thought a blog post like this might still be a useful addition to learning materials available. And also an opportunity for myself to learn.


Bignardi, G., Kievit, R., & Bürkner, P.-C. (2025). A general method for estimating reliability using Bayesian Measurement Uncertainty. OSF. https://doi.org/10.31234/osf.io/h54k8_v1

Bürkner, P.-C. (2021). Bayesian Item Response Modeling in R with brms and Stan. Journal of Statistical Software, 100, 1–54. https://doi.org/10.18637/jss.v100.i05


```{r}
library(tidyverse)
library(easyRasch)
library(brms)
library(qs2)
```

## Method

We won't check model fit, just assuming things work here, to see how the reliability metrics compare and how you specify Rasch models using `brms`. Default priors are used initially, which is not recommended.

## Rasch dichotomous model



### Bayesian

```{r}
#| eval: false
df <- eRm::raschdat1[,1:20] %>%
  rownames_to_column("id") %>%
  pivot_longer(!id, names_to = "item")

brms_rasch = brm(
  value ~ 1 + (1 | item) + (1 | id),
  data    = df,
  chains  = 4,
  cores   = 4,
  iter = 2000,
  family = "bernoulli"
)
qs_save(brms_rasch, file = "brms_rasch4000.qs2")
```


```{r}
brms_rasch8000 <- qs_read("brms_rasch8000.qs2")
brms_rasch4000 <- qs_read("brms_rasch4000.qs2")

# summary(brms_rasch)
# loo(brms_rasch)

posterior_draws_rm4000 = brms_rasch4000 %>%
  as_draws_df() %>%
  select(starts_with("r_id")) %>%
  t()

posterior_draws_rm8000 = brms_rasch8000 %>%
  as_draws_df() %>%
  select(starts_with("r_id")) %>%
  t()

RMUreliability(posterior_draws_rm4000)
RMUreliability(posterior_draws_rm8000)
```

### Compare to plausible values

From `TAM`

```{r}
#| echo: false

rr_rm <- RIreliability(eRm::raschdat1[,1:20], draws = 4000)
qs_save(rr_rm, file = "rr_rm.qs2")

rr_rm$RMU
rr_rm$EAP
rr_rm$PSI

rr_rm8000 <- RIreliability(eRm::raschdat1[,1:20], draws = 8000)
qs_save(rr_rm8000, file = "rr_rm8000.qs2")
rr_rm8000$RMU
```

### PVs with WLE and `mirt`

A *lot* faster than `TAM`, has an option to use WLE-estimated thetas (lower bias), and Metropolis-Hastings posterior draws. See `?mirt::fscores` for details.

```{r}
RIreliability2 <- function(data, conf_int = .95, draws = 1000, estim = "WLE", boot = FALSE, cpu = 4) {

  message("Note that PSI is calculated with max/min scoring individuals excluded.")

  if(min(as.matrix(data), na.rm = T) > 0) {
    stop("The lowest response category needs to coded as 0. Please recode your data.")
  } else if(max(as.matrix(data), na.rm = T) == 1) {
    model <- "RM"
  } else if(max(as.matrix(data), na.rm = T) > 1) {
    model <- "PCM"
  }

  if (model == "PCM") {
    mirt_out <- mirt(
      data,
      model = 1,
      itemtype = "Rasch",
      verbose = FALSE,
      accelerate = "squarem"
    )
    erm_out <- eRm::PCM(data)
  } else if (model == "RM") {
    mirt_out <- mirt(
      data,
      model = 1,
      itemtype = "1PL",
      verbose = FALSE,
      accelerate = "squarem"
    )
    erm_out <- eRm::RM(data)
  }

  wle <- RI_iarm_person_estimates(erm_out, properties = TRUE)[[2]] %>%
    as.data.frame()
  rownames(wle) <- NULL

  empirical_rel <- mirt::fscores(mirt_out,
                                 method = estim,
                                 theta_lim = c(-10, 10),
                                 full.scores.SE = TRUE,
                                 verbose = FALSE) %>%
    mirt::empirical_rxx()

  if (boot == TRUE) {
    require(doParallel)
    registerDoParallel(cores = cpu)
    # bootstrap CI for empirical
    fit <- data.frame()
    fit <- foreach(i = 1:draws, .combine = rbind) %dopar% {

      dat <- data[sample(1:nrow(data), nrow(data), replace = TRUE), ]

      if (model == "PCM") {
        mirt_out2 <- mirt(
          dat,
          model = 1,
          itemtype = "Rasch",
          verbose = FALSE,
          accelerate = "squarem"
        )
      } else if (model == "RM") {
        mirt_out2 <- mirt(
          dat,
          model = 1,
          itemtype = "1PL",
          verbose = FALSE,
          accelerate = "squarem"
        )
      }

      mirt::fscores(mirt_out2,
                    method = estim,
                    theta_lim = c(-10, 10),
                    full.scores.SE = TRUE,
                    verbose = FALSE) %>%
        mirt::empirical_rxx()

    }

    emp_boot <- mean_hdci(fit) %>%
      mutate(across(where(is.numeric), ~ round(.x, 3)))

  }

  plvals <- mirt::fscores(mirt_out, method = estim,
                          theta_lim = c(-10, 10),
                          plausible.draws = draws,
                          plausible.type = "MH",
                          verbose = FALSE)

  rmu <- do.call(cbind.data.frame, plvals) %>%
    RMUreliability(level = conf_int) %>%
    mutate(across(where(is.numeric), ~ round(.x, 3)))

  message(paste0("RMU reliability estimates based on ",draws," posterior draws (plausible values) from ",nrow(data)," respondents.",
                 "\nSee Bignardi, Kievit, & Bürkner (2025). 'A general method for estimating reliability using Bayesian Measurement Uncertainty' for details. ",
                 "The procedure has been modified in `easyRasch` to use `mirt::fscores(plausible.type = 'MH')` to generate plausible values based on an MML estimated Rasch model."))

  if (boot == TRUE) {

    return(list(WLE = wle,
                PSI = eRm::person.parameter(erm_out) %>% eRm::SepRel(),
                Empirical = paste0(estim,"_empirical = ",round(empirical_rel,3)),
                Empirical_bootstrap = paste0(estim,"_empirical = ",emp_boot$y," (95% HDCI [",emp_boot$ymin,", ",emp_boot$ymax,"]) (",draws," bootstrap resamples)"),
                RMU = paste0(estim,"-RMU = ",rmu$rmu_estimate," (95% HDCI [",rmu$hdci_lowerbound,", ",rmu$hdci_upperbound,"]) (",draws," draws)")
    )
    )
  } else {
    return(list(WLE = wle,
                PSI = eRm::person.parameter(erm_out) %>% eRm::SepRel(),
                Empirical = paste0(estim,"_empirical = ",round(empirical_rel,3)),
                RMU = paste0(estim,"-RMU = ",rmu$rmu_estimate," (95% HDCI [",rmu$hdci_lowerbound,", ",rmu$hdci_upperbound,"]) (",draws," draws)")
    )
    )
  }
}

```

```{r}
#| eval: false
rr_rm_wle <- RIreliability2(eRm::raschdat1[,1:20], draws = 4000)
rr_rm_eap <- RIreliability2(eRm::raschdat1[,1:20], draws = 4000, estim = "EAP")
rr_rm_wle8000 <- RIreliability2(eRm::raschdat1[,1:20], draws = 8000)

rr_rm_eap$RMU
rr_rm_wle$RMU
rr_rm_wle8000$RMU

rr_rm_wle$Empirical
```


### Conditional reliability

```{r}
RIrelRep(eRm::raschdat1[,1:20])$plot
RIrelRep(eRm::raschdat1[,1:20], rel = "omega")$plot
```


### Summary table

The `brms` model uses 

```{r}
data.frame(Metric = c("RMU Bayes 4000","RMU Bayes 8000","RMU PV 4000","RMU PV 8000","WLE-RMU PV 4000","WLE-RMU PV 8000","EAP","PSI","WLE empirical","Alpha","Omega"),
           Estimate = c("0.750, 95% HDCI [0.679, 0.819]",
                        "0.750, 95% HDCI [0.682, 0.823]",
                        "0.751, 95% HDCI [0.683, 0.818]",
                        "0.754, 95% HDCI [0.686, 0.821]",
                        "0.763, 95% HDCI [0.692, 0.825]",
                        "0.763, 95% HDCI [0.697, 0.826]",
                        "0.749",
                        "0.747",
                        "0.792",
                        "0.75 95% CI [0.68,0.82]",
                        "0.72 95% CI [0.64,0.79]")
           ) %>% 
  knitr::kable()
```


## Partial credit model

Polytomous/ordinal data, only 4 items in the dataset.

### Bayesian

To get a PCM, we need family = "acat", which defaults to use logit link.

```{r}
#| eval: false
df2 <- pcmdat2 %>%
  mutate(across(everything(), ~ .x + 1)) %>% # lowest category needs to be 1, unlike most Rasch packages that use 0
  rownames_to_column("id") %>%
  pivot_longer(!id, names_to = "item")

brms_pcm = brm(
  value | thres(gr = item) ~ 1 + (1 | id),
  data    = df2,
  chains  = 4,
  cores   = 4,
  iter = 2000,
  family = "acat",
  control = list(adapt_delta = 0.99)
)
loo(brms_pcm)

qs_save(brms_pcm, file = "brms_pcm.qs2")
```


```{r}
brms_pcm <- qs_read("brms_pcm.qs2")

summary(brms_pcm)
(brms_pcm_loo <- loo(brms_pcm))

mcmc_plot(brms_pcm)

posterior_draws_pcm = brms_pcm %>%
  as_draws_df() %>%
  select(starts_with("r_id")) %>%
  t()
```


### Compare to plausible values

```{r}
RMUreliability(posterior_draws_pcm)

rr_pcm <- RIreliability(eRm::pcmdat2, draws = 4000)
qs_save(rr_pcm, file = "rr_pcm.qs2")
rr_pcm$RMU
rr_pcm$EAP
rr_pcm$PSI
```

### WLE-RMU & WLE empirical

```{r}
rr_pcm_wle <- RIreliability2(eRm::pcmdat2, draws = 4000)

rr_pcm_wle$RMU

rr_pcm_wle$Empirical
```


### Conditional reliability

```{r}
RIrelRep(eRm::pcmdat2)$plot
RIrelRep(eRm::pcmdat2, rel = "omega")$plot
```

```{r}
data.frame(Metric = c("RMU Bayes 4000","RMU PV 4000","WLE-RMU PV 4000","EAP","WLE empirical","PSI","Alpha","Omega"),
           Estimate = c("0.670, 95% HDCI [0.610, 0.723]",
                        "0.664, 95% HDCI [0.612, 0.713]",
                        "0.671, 95% HDCI [0.62, 0.722]",
                        "0.669",
                        "0.718",
                        "0.380",
                        "0.66 95% CI [0.59,0.72]",
                        "0.63 95% CI [0.57,0.70]")
           ) %>% 
  knitr::kable()
```

